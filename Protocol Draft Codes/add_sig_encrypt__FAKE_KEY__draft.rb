require ('openssl')

# NOTE: https://blog.bigbinary.com/2011/07/20/ruby-pack-unpack.html
# This explains how to pack and unpack data.
# This needs to be set correctly to mirror the encryption operation happening on the MSP430

# TODO: Fix the byte orders to mirror the MSP430

module Cosmos
    class AddSigEncrypt < Protocol

        PAD_VAL = 0x00
        # THIS IS THE FAKE KEY
        MASTER_KEY = [0x0e, 0xad, 0x0c, 0x72, 0xc2, 0x61, 0x4e, 0xb8, 0xee, 0x03, 0x5c, 0x09, 0xc3, 0x4c, 0xc3, 0x01,
            0x94, 0xa7, 0x32, 0xee, 0x7b, 0xfb, 0xbc, 0x63, 0x53, 0x71, 0x40, 0x5c, 0x2e, 0x5c, 0x48, 0xae,
            0x0e, 0xad, 0x0c, 0x72, 0xc2, 0x61, 0x4e, 0xb8, 0xee, 0x03, 0x5c, 0x09, 0xc3, 0x4c, 0xc3, 0x01,
            0x94, 0xa7, 0x32, 0xee, 0x7b, 0xfb, 0xbc, 0x63, 0x53, 0x71, 0x40, 0x5c, 0x2e, 0x5c, 0x48, 0xae,
            0x0e, 0xad, 0x0c, 0x72, 0xc2, 0x61, 0x4e, 0xb8, 0xee, 0x03, 0x5c, 0x09, 0xc3, 0x4c, 0xc3, 0x01,
            0x94, 0xa7, 0x32, 0xee, 0x7b, 0xfb, 0xbc, 0x63, 0x53, 0x71, 0x40, 0x5c, 0x2e, 0x5c, 0x48, 0xae,
            0x94, 0xa7, 0x32, 0xee, 0x7b, 0xfb, 0xbc, 0x63, 0x53, 0x71, 0x40, 0x5c, 0x2e, 0x5c, 0x48, 0xae,
            0x94, 0xa7, 0x32, 0xee, 0x7b, 0xfb, 0xbc, 0x63, 0x53, 0x71, 0x40, 0x5c, 0x2e, 0x5c, 0x48, 0xae,
            0x94, 0xa7, 0x32, 0xee, 0x7b, 0xfb, 0xbc, 0x63, 0x53, 0x71, 0x40, 0x5c, 0x2e, 0x5c, 0x48, 0xae,
            0x94, 0xa7, 0x32, 0xee, 0x7b, 0xfb, 0xbc, 0x63, 0x53, 0x71, 0x40, 0x5c, 0x2e, 0x5c, 0x48, 0xae,
            0x94, 0xa7, 0x32, 0xee, 0x7b, 0xfb, 0xbc, 0x63, 0x53, 0x71, 0x40, 0x5c, 0x2e, 0x5c, 0x48, 0xae,
            0x94, 0xa7, 0x32, 0xee, 0x7b, 0xfb, 0xbc, 0x63, 0x53, 0x71, 0x40, 0x5c, 0x2e, 0x5c, 0x48, 0xae,
            0x94, 0xa7, 0x32, 0xee, 0x7b, 0xfb, 0xbc, 0x63, 0x53, 0x71, 0x40, 0x5c, 0x2e, 0x5c, 0x48, 0xae,
            0x94, 0xa7, 0x32, 0xee, 0x7b, 0xfb, 0xbc, 0x63, 0x53, 0x71, 0x40, 0x5c, 0x2e, 0x5c, 0x48, 0xae,
            0x94, 0xa7, 0x32, 0xee, 0x7b, 0xfb, 0xbc, 0x63, 0x53, 0x71, 0x40, 0x5c, 0x2e, 0x5c, 0x48, 0xae,
            0x94, 0xa7, 0x32, 0xee, 0x7b, 0xfb, 0xbc, 0x63, 0x53, 0x71, 0x40, 0x5c, 0x2e, 0x5c, 0x48, 0xae,
            0x0e, 0xad, 0x0c, 0x72, 0xc2, 0x61, 0x4e, 0xb8, 0xee, 0x03, 0x5c, 0x09, 0xc3, 0x4c, 0xc3, 0x01]

        def write_data(payload)

            master_key = MASTER_KEY

            # Check Master Key is 272 bytes long
            unless master_key.length == 272
                raise 'SIG ERROR: Master Key is not 272 bytes long'
            end

            # Setup the buffer based on the command.
            # Make sure that the entire data is length % 16 == 0
            command = payload.bytes.to_a
            command_str = command.pack('C*')
            command_hex = command_str.unpack('H*')

            # Padding
            padding = []
            if (command.length % 16 > 0)
                padding = [PAD_VAL] * (16 - command.length % 16)
            end

            # Pad the input message to the correct length and convert
            buffer = (command + padding).pack('C*')

            # Generate a random key index to use for this packet
            key_idx = rand(0..255)

            # Setup the encryption module
            key = master_key[key_idx..key_idx + 15]
            aes = OpenSSL::Cipher.new('AES-128-ECB')
            aes.encrypt
            aes.key = key
            result = aes.update(buffer)

            # NOTE: Not quite sure if these are the right formats for unpacking things
            # 32-bit unsigned, Network (big-endian) byte order (N)
            # 32-bit unsigned integer (big endian) (L>*)
            # 32-bit unsigned integer (little endian) (L*)
            loops = buffer.length / 4
            signature = 0
            # Calculate the signature by doing an XOR operation
            for i in 0..(loops-1)
                start_idx = i*4
                end_idx = ((i+1)*4)-1
                chunk = result[start_idx..end_idx].unpack("L*")
                signature = chunk[0] ^ signature
            end

            payload_send = command + key_idx.bytes.to_a + signature
            payload_send_st = payload_send.pack("C*")

            return payload_send_st

        end
    end
end